 >7.1 주소 바인딩
  - 프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 **독자적인** 주소 공간이 생성됨
    - 이 공간이 논리적 주소, 혹은 가상 주소이다.
  - 물리적 주소는 물리적 메모리에 실제로 올라가는 위치이다.
  - CPU는 논리적 주소에 근거해 명령을 실행하기 때문에 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 함
  - 논리적 주소를 물리적 메모리 주소로 연결시키는게 **주소 바인딩**이다.
  - 주소 바인딩 방식
    - 컴파일 타임 바인딩 = 절대코드를 생성하는 바인딩 방식 (잘 사용 x)
    - 로드 타임 바인딩
    - 실행 시간 바인딩
      - 주소 매핑 테이블을 이용해 바인딩을 점검
      - 기준 레지스터, 한계 레지스터, mmu 필요
  <br>
  <br>
  - MMU(Memory Management Unit) 기법
    - CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어냄
    - 이때 기준 레지스터 = 재배치 레지스터, 프로세스의 물리적 메모리 시작 주소를 가지고 있음
    - 여기서 논리적 주소는 offset 역할
    - 한계 레지스터를 이용해 다른 프로세스가 특정 프로세스의 메모리 영역을 침범하는 것을 방지함
    - 침범하려고 시도하면 트랩 발생
    

<br>

 >7.2 메모리 관리와 관련된 용어
  - 동적 로딩 (dynamic loading)
    - 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법
    - 필요한 프로그램을 메모리에 다 올리는 것이 아닌, 부분만 메모리에 적재하는 방식
  - 동적 연결 (dynamic linking)
    - 연결이란 object file과 라이브러리 파일들을 묶어 하나의 실행파일을 생성하는 과정 (새로운 코드 + 기존 코드를 묶는 과정임)
    - 동적 연결은 이 둘 사이의 연결을 실행 시점까지 지연시키는 것
    - 즉, 라이브러리 실행 시점에 연결함
    - 라이브러리 위치는 스텁(stub)에 저장
  - 중첩 (overlays)
    - 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법
    - 동적 로딩과 개념적으로 유사함
    - 동적 로딩은 다중 프로그래밍 환경에서의 효율성을 위한 방법
    - 중첩은 하나의 프로세스조차 올리기 어려울 때 사용한 방법
  - 스와핑 (swapping)
    - 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것
    - 스왑 영역 = 백킹 스토어(backing store)
    - 스와핑은 스와퍼라고 불리는 중기 스케줄러에의해 스왑 아웃시킬 프로세스를 선정한다.
    


<br>

>7.3 물리적 메모리의 할당 방식
  - 물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉨
    - 운영체제 상주 영역은 인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역 사용, 커널이 이곳에 위치
      - 인터럽트 벡터 : 인터럽트 벡터는 인터럽트가 발생했을 때, 그 인터럽트를 처리할 수 있는 서비스 루틴들의 주소를 가지고 있는 공간.
    - 사용자 프로세스 영역은 물리적 메모리의 높은 주소 영역 사용
  <br>
  <br>
  - 사용자 프로세스 영역 관리방법
    - 프로세스를 메모리에 올리는 방식에 따라 구분
    - 연속할당 (contiguous allocation) : 메모리에 연속적으로 할당 / 고정분할, 가변분할
    - 불연속 할당 (noncontiguous allocation) : 여러 영역에 분산해 적재 / 페이징, 세그먼테이션, 페이지드 세그먼테이션
    
  <br>
  <br>

  - 연속 할당 방식
    - 고정분할
      - 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나눔
      - 외부조각, 내부조각 모두 발생
    - 가변분할
      - 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변함
      - 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 가용 공간 중 어떤 위치에 올리느냐가 중요하다 (동적 메모리 할당 문제)
        - first fit
        - best fit
        - worst fit

<br>

>7.4 페이징 기법
  - 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식
  - 페이징 기법에서는 물리적 메모리를 페이지와 동일한 크기의 프레임으로 미리 나눔
  - 페이징 기법에서는 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블을 가짐 (페이지 테이블은 메모리에 저장)

<br>
<br>

  - 주소 변환기법
    - 페이징 기법에서는 CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환에 사용
    - 페이지 번호로 물리적 메모리주소 시작점을 찾아내고 오프셋을 더해 정확한 주소 찾음
  - 페이지 테이블의 구현
    - 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터 사용
    - 페이지 테이블 기준 레지스터(page-table base register)
      - 메모리 내에서의 페이지 테이블의 시작 위치
    - 페이지 테이블 길이 레지스터(page-table length register)
      - 페이지 테이블 크기
    - 매번 페이지 테이블을 찾아가면 오버헤드가 커서 TLB 사용
    - TLB(Translation Look-aside Buffer) : 고속의 주소 변환용 하드웨어 캐시
    - 페이지 테이블은 전체 서칭 해야하는데 TLB는 바로 찾아갈 수 있음
    - TLB의 구현에는 일반적으로 병렬탐색이 가능한 연관 레지스터 사용
  - 계층적 페이징
    - 페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 계층적 페이징 사용
    - 계층이 많아질수록 페이지 테이블을 위해 사용되는 메모리 공간의 소모는 줄일 수 있지만, 메모리 접근 횟수가 많아져서 메모리 접근 시간이 크게 늘어날 수 있음
    - TLB가 가장 효율적이다.
  - 역페이지 테이블
    - 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식
    - 논리적 주소에 대해 페이지 테이블을 만드는 것이 아닌, 물리적 주소에 대해 페이지 테이블을 만드는 것
  - 공유 페이지
    - 공유 코드를 담고있는 페이지
  - 메모리 보호
    - 페이지 테이블의 각 항목에는 주소 변환 정보뿐 아니라 메모리 보호를 위한 보호 비트와 유효-무효 비트를 두고 있음
    - 보호비트는 각 페이지에 대한 접근 권한의 내용을 담음
    - 유효-무효 비트는 페이지의 내용이 유효한지에 대한 내용
  

<br>

>7.5 세그먼테이션
  - 프로세스의 주소 공간을 의미 단위의 세그먼트로 나누어 메모리에 올리는 방식
  - 하나의 프로세스의 주소 공간은 주로 스택, 데이터, 코드로 이루어진다.
    - 세그먼트는 이런 의미 단위를 가리킨다.
  - 세그먼트 테이블을 사용
    - 각 항목의 기준점과 한계점을 가지고 있음
  - 의미 단위로 나누어져 있어 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적
  - 하지만 의미 단위로 나누기 때문에 길이가 페이지 처럼 균일하지 않음 


<br>

>7.6 페이지드 세그먼테이션
  - 앞선 페이징기법과 세그먼테이션 기법의 장점을 채용한 방식
  - 일단 프로그램을 의미 단위인 세그먼트로 나눔
  - 단 세그먼트가 임의의 길이를 가지는것이 아닌, 반드시 동일한 크기 페이지들의 집합으로 구성되어야 함
  - 물리적 메모 적재 단위는 페이지다.

