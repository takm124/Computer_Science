[TOC]

# 관계대수와 SQL



- 관계 데이터 모델에서 지원되는 두 가지 정형적인 언어

  - 관계 해석 (relational calculus)

    - 원하는 데이터만 명시하고 질의를 어떻게 수행할 것인가는 명시하지 않는 선언적인 언어

    

  - 관계 대수 (relational algebra)

    - 어떻게 질의를 수행할 것인가를 명시하는 절차적 언어
    - 관계 대수는 상용 관계 DMS들에서 널리 사용되는 SQL의 이론적인 기초
    - 관계 대수는 SQL을 구현하고 최적화하기 위해 DMS의 내부 언어로서도 사용됨





- SQL
  - 상용 관계 DBMS들의 사실상의 표준 질의어인 SQL을 이해하고 사용할 수 있는 능력은 매우 중요함
  - 사용자는 SQL을 사용하여 관계 데이터베이스에 릴레이션을 정의하고, 관계 데이터베이스에서 정보를 검색하고, 관계 데이터베이스를 갱신하며, 여러가지 무결성 제약조건들을 명시할 수 있음





# 관계 대수

- 관계 대수
  - 기존의 릴레이션들로부터 새로운 릴레이션을 생성함
  - 릴레이션이나 관계 대수식(이것의 결과도 릴레이션)에 연산자들을 적용하여 보다 복잡한 관계 대수식을 점차적으로 만들 수 있음
  - 기본적인 연산자들의 집합으로 이루어짐
  - 산술 연산자와 유사하게 단일 릴레이션이나 두 개의 릴레이션을 입력으로 받아 하나의 결과 릴레이션을 생성함
  - 결과 릴레이션은 또 다른 관계 연산자의 입력으로 사용될 수 있음



![관계대수](https://player.slidesplayer.org/90/14426990/slides/slide_5.jpg)



- 필수적인 연산자 : 필수적으로 있어야 함 (없으면 계산 안됨)

![관계 대수 2](https://player.slidesplayer.org/90/14426990/slides/slide_6.jpg)





## 셀렉션 연산자

- 한 릴레이션에서 `셀렉션 조건`(selection condition)을 만족하는 튜플들의 부분 집합을 생성함 (튜플 = row, record)
- 단항 연산자
- 결과 릴레이션의 차수는 입력 릴레이션의 차수와 같음
- 결과 릴레이션의 카디날리티는 항상 원래 릴레이션의 카디날리티보다 작거나 같음 (카디날리티 = 릴레이션 튜플의 개수)
- 셀렉션 조건을 프레디키트(predicate)라고도 함
- 셀렉션 조건은 일반적으로 릴레이션의 임의의 애트리뷰트와 상수, =, <>, <=, <, >=, > 등의 비교 연산자, AND, OR, NOT 등의 bool 연산자를 포함할 수 있음 (애트리뷰트 = column)

![selection](https://player.slidesplayer.org/90/14426990/slides/slide_8.jpg)





## 프로젝션 연산자

- 한 릴레이션의 애트리뷰트들의 부분 집합을 구함
- 결과로 생성되는 릴레이션은 <애트리뷰트 리스트>에 명시된 애트리뷰트들만 가짐
- 셀렉션 결과 릴레이션에는 중복 튜플이 존재할 수 없지만, 프로젝션 연산의 결과 릴레이션에는 중복된 튜플들이 존재할 수 있음
  - 중복 제거 연산이 오래걸려서 안함

![프로젝션](https://player.slidesplayer.org/90/14426990/slides/slide_10.jpg)

![프로젝션2](https://player.slidesplayer.org/90/14426990/slides/slide_11.jpg)





## 집합 연산자

- 릴레이션이 튜플들의 집합이기 때문에 기존의 집합 연산이 릴레이션에 적용됨
- 세 가지 집합 연산자 : 합집합, 교집합, 차집합 연산자
- 집한 연산자의 입력으로 사용되는 두 개의 릴레이션은 합집합 호환(union compatible)이어야 함
- 이항 연산자



- 합집합 호환
  - 두 릴레이션 R1(A1, A2, ...An)과 R2(B1, B2, ...Bm)이 합집합 호환일 필요 충분 조건은 n = m이고 모든 1 <= i <= n 에 대해 domain(Ai) = domain(Bi)



## 합집합 연산자

- 두 릴레이션 R과 S의 합집합 R U S는 R 또는 S에 있거나 R과 S 모두에 속한 튜플들로 이루어진 릴레이션
- 결과 릴레이션에서 중복된 튜플들은 제외됨
- 결과 릴레이션의 차수는 R 또는 S의 차수와 같으며, 결과 릴레이션의 애트리뷰트 이름들은 R의 애트리뷰트들의 이름과 같거나 S의 애트리뷰트들의 이름과 같음



![합집합1](https://player.slidesplayer.org/90/14426990/slides/slide_15.jpg)

![합집합2](https://player.slidesplayer.org/90/14426990/slides/slide_16.jpg)



## 카티션 곱 연산자

- 카디날리티가 i인 릴레이션 R(A1, A2, ...., An)과 카디날리티가 j인 릴레이션 S(B1, B2, ..., Bm)의 카티션 곱 R x S 는 차수가 n + m이고, 카디날리티가 i * j이고, 애트리뷰트가 (A1, A2, ..., An, B1, B2, ..., Bm)이며, R과 S의 튜플들의 모든 가능한 조합으로 이루어진 릴레이션



- 카티션 곱의 결과 릴레이션의 크기가 매우 클 수 있으며, 사용자가 실제로 원하는 것은 카티션 곱의 결과 릴레이션의 일부인 경우가 대부분이므로 카티션 곱 자체는 유용한 연산자가 아님



![카티션 곱](https://player.slidesplayer.org/90/14426990/slides/slide_24.jpg)



## 관계 대수의 완전성

- 셀렉션, 프로젝션, 합집합, 차집합, 카티션 곱은 관계 대수의 필수적인 연산자
- 다른 관계 연산자들은 필수적인 관계 연산자를 두 개 이상 조합하여 표현할 수 있음
- 임의의 질의어가 적어도 필수적인 관계 대수 연산자들만큼의 표현력을 갖고 있으면 관계적으로 완전(relationally complete)하다고 말함





## 조인 연산자

- 두 개의 릴레이션으로부터 연관된 튜플들을 결합하는 연산자
- 관계 데이터베이스에서 두 개 이상의 릴레이션들의 관계를 다루는데 매우 중요한 연산자
- 세타 조인(theta join), 동등 조인(equijoin), 자연 조인(natural join), 외부 조인(outer join), 세미 조인(semijoin) 등





### 세타 조인과 동등 조인

- 두 릴레이션 R(A1, A2, ..., An)과 S(B1, B2, ..., Bm)의 세타 조인의 결과는 차수가 n+m이고, 애트리뷰트가 (A1, A2, ..., An, B1, B2, ..., Bm)이며, 조인 조건을 만족하는 튜플들로 이루어진 릴레이션
- 세타는 {=, <>, <=, <, >=, >} 중의 하나 // <> 는 !=의 의미
- 동등 조인은 세타 조인중에서 비교 연산자가 =인 조인



![동등 조인](https://player.slidesplayer.org/90/14426990/slides/slide_28.jpg)





### 자연 조인

- 동등 조인의 결과 릴레이션에서 조인 애트리뷰트를 제외한 조인
- 여러 가지 조인 연산자들 중에서 가장 자주 사용됨
- 실제로 관계 데이터베이스에서 대부분의 질의는 셀렉션, 프로젝션, 자연조인으로 표현 가능

![자연 조인](https://player.slidesplayer.org/90/14426990/slides/slide_30.jpg)





## 관계 대수의 한계

- 관계 대수는 산술 연산을 할 수 없음
- 집단 함수(aggregate function)를 지원하지 않음
- 정렬을 나타낼 수 없음
- 데이터베이스를 수정할 수 없음
- 프로젝션 연산의 결과에 중복된 튜플을 나타내는 것이 필요할 때가 있는데 이를 명시하지 못함