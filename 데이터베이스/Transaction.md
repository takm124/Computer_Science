[TOC]



# 트랜잭션

- 데이터베이스 어플리케이션



- TPS (Transaction per second)이 성능의 척도



- 많은 사용자들이 동시에 데이터베이스의 서로 다른 부분 또는 동일한 부분을 접근하면서 데이터베이스를 사용함
  - 동시성 문제가 발생 할 수 있다.



- 동시성 제어 (Concurrency Control)
  - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장함
  - 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성을 유지함



- 회복(Recovery)
  - 데이터베이스를 갱신하는 도중에 시스템이 고장나도 데이터베이스의 일관성을 유지함



  

## 트랜잭션 개요

![T1-1](https://player.slidesplayer.org/95/16379699/slides/slide_4.jpg)

![T1-2](https://player.slidesplayer.org/95/16379699/slides/slide_5.jpg)



  

### **트랜잭션의 특성 (ACID)**

```
간단 요약

Atomicity : 원자성. 트랜잭션과 관련된 일은 모두 실행되던지 모두 실행되지 않도록 하던지를 보장하는 특성이다.

Consistency : 일관성. 트랜잭션이 성공했다면, 데이터베이스는 그 일관성을 유지해야 한다. 일관성은 특정한 조건을 두고, 그 조건을 만족하는지를 확인하는 방식으로 검사할 수 있다.

Isolation : 독립성. 트랜잭션을 수행하는 도중에 다른 연산작업이 끼어들지 못하도록 한다. 임계영역을 두는 것으로 달성할 수 있다.

Durability : 성공적으로 트랜잭션이 수행되었다면, 그 결과는 완전히 반영이 되어야 한다. 완전히 반영되면 로그를 남기게 되는데, 후에 이 로그를 이용해서 트랜잭션 수행전 상태로 되돌릴 수 있어야 한다. 때문에 트랜잭션은 로그저장이 완료된 시점에서 종료가 되어야 한다.
```



- 원자성 (Atomic)
  - 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(All or Nothing)
  - DBMS의 회복 모듈은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장함
  - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장함
    - 트랜잭션 로그 데이터 활용

  

- 일관성 (Consistency)
  -  어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
  - 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지 않을 수 있음

​    

- 고립성 (Isolation)
  - 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
  - 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
  - DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장함
  - DBMS는 응용들의 요구사항에 따라 다양한 고립 수준(isolation level)을 제공함

​    

- 지속성 (Durability)
  - 일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템이 고장이 발생하더라도 손실되지 않음
  - 완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 반영됨
  - DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장함

  

![ 트랜잭션 특성 ](https://player.slidesplayer.org/95/16379699/slides/slide_16.jpg)

  

  

- 트랜잭션의 완료(Commit)
  - 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영됨
  - SQL 구문상으로 COMMIT WORK

  

- 트랜잭션의 철회(Abort)
  - 트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해서, 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림
  - SQL 구문상으로 ROLLBACK WORK

![commit, rollback](https://player.slidesplayer.org/95/16379699/slides/slide_18.jpg)

  

  

- 트랜잭션이 성공하지 못한느 원인
  - 시스템(사이트) 고장
    - 중앙 처리 장치, 주기억 장치, 전원 공급 장치 등이 고장남
  - 트랜잭션 고장
    - 트랜잭션 고장은 트랜잭션이 수행되는 도중에 철회됨
  - 매체 고장
    - 디스크 헤드, 디스크 컨트롤러 등이 고장나서 보조 기억 장치의 전부 또는 일부 내용이 지워짐
  - 통신 고장
  - 자연적재해
  - 부주의 또는 고의적인 고장

  

  

  

  

## 동시성 제어 (Concurrency Control)

- 대부분의 DBMS들은 다수 사용자가 사용한다.
- 여러 사용자들이 동시에 동일한 테이블에 접근하기도 한다.
- DBMS의 성능을 높이기 위해 여러 사용자의 질의나 프로그램들을 동시에 수행하는 것이 필수적이다.
- 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션들을 동시에 수행하는 환경에서 부정확한 결과를 생성할 수 있는, 트랜잭션들 간의 간섭이 생기지 않도록 함

  

  

- `직렬 스케줄  (serial schedule)`

  - 여러 트랜잭션들의 집합을 한 번에 한 트랜잭션씩 차례대로 수행

      

- `비직렬 스케줄 (non-serial schedule)`

  - 여러 트랜잭션들을 동시에 수행함

      

- `직렬가능 (serializable)`

  - 비직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행결과와 동등함
  - 개발자는 serializable한 스케쥴을 만들어야 한다.





### 데이터베이스 연산

- Input(X) 연산은 데이터베이스 항목 X를 포함하고 있는 블록을 주기억장치의 버퍼로 읽어들임
- Output(X) 연산은 데이터베이스 항목 X를 포함하고 있는 블록을 디스크에 기록함
- read_item(X) 연산은 주기억 장치 버퍼에서 데이터베이스 항목 X의 값을 프로그램 변수 X로 복사함
- write_item(X) 연산은 프로그램 변수 X의 값을 주기억 장치 내의 데이터베이스 항목 X에 기록함

  

![연산](https://player.slidesplayer.org/95/16379699/slides/slide_25.jpg)

- 즉 버퍼에 올려서 데이터를 공유함

  

- 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제 (예시 27 ~ 34p)
  - 갱신 손실 (lost update)
    - 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효화 되는 것
  - 오손 데이터 읽기 (dirty read)
    - 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것
    - dirty data를 읽더라도 절대 commit하면 안된다.
  - 반복할 수 없는 읽기 (unrepeatable read)
    - 한 트랜잭션이 동일한 데이터를 두 번 읽었는데  서로 다른 값을 읽게 되는 것
    - 고립성을 위반하게 되는 것

  

​    

## 락킹(locking)

- 데이터 항목을 락킹하는 개념은 동시에 수행되는 트랜잭션들의 동시성을 제어하기 위해서 가장 널리 사용되는 기법
- 락 (lock)은 데이터베이스 내의 각 데이터 항목과 연관된 하나의 변수
- 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 락에 관한 정보는 락 테이블(lock table) 등에 유지됨
- 트랜잭션에서 **갱신**을 목적으로 데이터 항목을 접근할 때는 독점 락(X-lock, exclusive lock)을 요청함
- 트랜잭션에서 **읽을** 목적으로 데이터 항목을 접근할 때는 공유 락(S-lock, Shared lock)을 요청함
- 트랜잭션이 데이터 항목에 대한 접근을 끝낸 후에 락을 해제(unlock) 함
  - unlock의 타이밍이 중요하다.
  - 데이터를 더 이상 사용하지 않으면 바로 unlock을 해줘야함 (병렬성이 높아짐)
  - but, 너무 빠르게 unlock 하면 동시성 문제 발생할 수 있음
  - 본인 트랜잭션 commit 후 한번에 unlock 하는 것이 안전하긴 함

  

![락 양립성](https://player.slidesplayer.org/95/16379699/slides/slide_36.jpg)

  

- 2단계 락킹 프로토콜 (2-phase locking protocol)
  - 락을 요청하는 것과 락을 해제하는 것이 2단계로 이루어짐
  - 락 확장 단계가 지난 후에 락 수축 단계에 들어감
  - 일단 락을 한개라도 해제하면 락 수축 단계에 들어감

![락킹 프로토콜](https://player.slidesplayer.org/95/16379699/slides/slide_38.jpg)

  

- 락 확장 단계 (1단계, first phase)
  - 락 확장 단계에서는 트랜잭션이 데이터 항목에 대하여 새로운 락을 요청할 수 있지만 보유하고 있던 락을 하나라도 해제할 수 없음

  

- 락 수축 단계 (2단계, second phase)
  - 락 수축 단계에서는 보유하고 있던 락을 해제할 수 있지만 새로운 락을 요청할 수 없음
  - 락 수축 단계에서는 락을 조금씩 해제할 수도 있고, 트랜잭션이 완료 시점에 이르렀을 때 한꺼번에 모든 락을 해제할수도 있음
  - 일반적으로 한꺼번에 해제하는 방식이 사용됨
    - 하나씩 해제하면 데드락 발생할 수 있음

  

- 락 포인트 (lock point)는 한 트랜잭션에서 필요로 하는 모든 락을 걸어놓은 시점

![락킹](https://player.slidesplayer.org/95/16379699/slides/slide_40.jpg)

  

  

- 데드락(deadlock)
  - 2단계 락킹 프로토콜에서는 데드락이 발생할 수 있음
  - 데드락은 두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 락을 요청하면서 기다리고 있는 상태를 말함
  - 데드락을 해결하기 위해서는 데드락을 방지하는 기법이나, 데드락을 탐지하고 희생자(Victim)를 선정하여 데드락을 푸는 기법 등을 사용함

  

  ### 다중 락 단위(multiple granularity)

- 대부분의 트랜잭션들이 소수의 튜플(row)들을 접근하는 데이터베이스 응용에서는 튜플 단위로 락을 해도 락 테이블을 다루는 시간이 오래 걸리지 않음
- 트랜잭션들이 많은 튜플을 접근하는 데이터베이스 응요에서 튜플 단위로만 락을 한다면 락 테이블에서 락 충돌을 검사하고, 락 정보를 기록하는 시간이 오래 걸림
- 트랜잭션이 접근하는 튜플의 수에 따라 락을 하는 데이터 항목의 단위를 구분하는 것이 필요함
- 한 트랜잭션에서 락을 할 수 있는 데이터 항목이 두 가지 이상 있으면 다중 락 단위라고 말함
- 데이터베이스에서 락을 할 수 있는 다누이로는 데이터베이스, 릴레이션(테이블), 디스크 블록, 튜플 등

- 일반적으로 DBMS는 각 트랜잭션에서 접근하는 튜플 수에 따라 자동적으로 락 단위를 조정함
- 락 단위가 작을수록 락킹에 따른 오버헤드가 증가함
  - 락을 관리하는 단위가 너무 디테일하므로 부담이 증가함
- 락 단위가 작을수록 동시성의 정도는 증가함
  - 디테일하게 컨트롤하니까 동시성 증가함

  

  

![다중 락 단위](https://player.slidesplayer.org/95/16379699/slides/slide_45.jpg)

​    

  

## 회복 (recovery)

### 회복의 개요

- 기본적으로 log-based recovery
- 여러 어플리케이션이 주기억 장치 버퍼 내의 동일한 데이터베이스 항목을 갱신한 후에 디스크에 기록함으로써 성능을 향상시키는 것이 중요함
- 버퍼의 내용을 디스크에 기록하는 것을 가능하면 최대한 줄이는 것이 일반적
- 트랜잭션이 버퍼에는 갱신 사항을 반영했지만 버퍼의 내용이 디스크에 기록되기 전에 고장이 발생할 수 있음
- 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행했다면 회복 모듈은 이 트랜잭션의 갱신 사항을 재수행(REDO)하여 트랜잭션의 갱신이 지속성을 갖도록 해야함
- 고장이 발생하기 전에 트랜잭션이 완료 명령을 수행하지 못했다면 원자성을 보장하기 위해서 이 트랜잭션이 데이터베이스에 반영했을 가능성이 있는 갱신 사항을 취소(UNDO) 해야함



### 저장 장치의 유형

- 로그도 결국 디스크에 저장된다.
- 주기억 장치와 같은 휘발성 저장 장치에 들어 있는 내용은 시스템이 다운된 후에 모두 사라짐
- 디스크와 같은 비휘발성 저장 장치에 들어 있는 내용은 디스크 헤드 들이 손상을 입지 않는 한 시스템이 다운된 후에도 유지됨
- 안전 저장 장치(stable storage)는 모든 유형의 고장을 견딜 수 있는 저장 장치를 의미
- 두 개 이상의 비휘발성 저장 장치가 동시에 고장날 가능성이 매우 낮으므로 비휘발성 저장 장치에 두 개 이상의 사본을 중복해서 저장함으로써 안전 저장장치를 구현

### 



사진 출처 : https://slidesplayer.org/slide/16379699/